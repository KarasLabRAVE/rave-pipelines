---
title: "RAVE Power Explorer"
format: html
output:
  html_document: default
  pdf_document: default
editor_options:
  chunk_output_type: console
chunk_output_type: console
---

```{r setup, include = FALSE}
# This code block sets up the engine environment
# Please do not remove me
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
build_pipeline <- raveio::configure_knitr()
# For debug use, try to mimic the environment of pipeline
# Load R scripts starting with `shared-` in R/ folder
.project_path <- rstudioapi::getActiveProject()
lapply(
    list.files(
        file.path(.project_path, "modules", "power_explorer", "R"),
        pattern = "^shared-.*\\.R$",
        ignore.case = TRUE,
        full.names = TRUE
    ),
    function(f){
        source(f, local = FALSE, chdir = TRUE)
        invisible(TRUE)
    })
# Load variables in `settings.yaml` and expose them to the current environment
.settings <- raveio::load_yaml(file.path(
    .project_path, "modules",
    'power_explorer', "settings.yaml"))

list2env(as.list(.settings), envir = environment())
```

```{rave check_load_power, language = "R", export = "repository", cue = "always"}
proj_subj <- sprintf("%s/%s", project_name, subject_name)

repository <- raveio::prepare_subject_power(
  subject = subject, electrodes = loaded_electrodes, 
  epoch_name = epoch_choice, reference_name = reference_name,
  time_windows = c(epoch_choice__trial_starts, epoch_choice__trial_ends))

repository
```

```{rave check_requested_electrodes, language = "R", export = "requested_electrodes"}
requested_electrodes <- dipsaus::parse_svec(analysis_electrodes, sep=',|;', connect  = ':-')
requested_electrodes <- requested_electrodes[requested_electrodes %in% repository$power$dimnames$Electrode]
if(!length(requested_electrodes)){ stop("No electrode selected") }
```

```{rave check_analysis_settings, language = "R", export = "analysis_checks_passed"}
analysis_checks_passed = FALSE

check_range <- function(x, lim, lbl) {
  if(!all(x %within% lim)) stop(sprintf('Requested %s [%s] not within available range [%s]', lbl, str_collapse(range(x), ':'), str_collapse(range(lim), ':')), call. = FALSE)
}

# check repo settings
if(length(repository$time_windows) != 1) stop('discontinuous time windows not supported')

# first ensure all analysis settings are vectors, not lists
analysis_settings_clean <- lapply(analysis_settings, function(as) {
  as$time %<>% unlist
  as$frequency %<>% unlist
  
  if(is.null(as$label) || nchar(as$label) < 1) {
    as$label <- paste('Window', rand_string(length = 4))
  }
  
  if(is.null(as$censor_info)) {
    as$censor_info <- list(
      enabled=FALSE, window = 0:1
    )
  }
  
  return(as)
})

# ensure baseline choices are valid
ua <- get_unit_of_analysis(names=TRUE)
if(!baseline_settings$unit_of_analysis %in% ua) {
  stop(sprintf('Requested unit of analysis "%s" must be one of: %s', baseline_settings$unit_of_analysis, str_collapse(ua)))
}

ua <- get_baseline_scope(names=TRUE)
if(!baseline_settings$scope %in% ua) {
  stop(sprintf('Requested baseline scope "%s" must be one of: %s', baseline_settings$scope, str_collapse(ua)))
}

# ensure analysis choices are valid
lapply(analysis_settings_clean, function(setting) {
  check_range(setting$frequency, unlist(repository$frequency), 'frequency')
  check_range(setting$time, unlist(repository$time_windows), 'analysis time')
})

names(analysis_settings_clean) <- sapply(analysis_settings_clean, `[[`, 'label')

#ensure no duplicated names
dd <- duplicated(sapply(analysis_settings_clean, `[[`, 'label'))
while(sum(dd)) {
  for(w in which(dd)) {
    analysis_settings_clean[[w]]$label = paste(analysis_settings_clean[[w]]$label,
                                               rand_string(length = 4))
  }
  dd <- duplicated(sapply(analysis_settings_clean, `[[`, 'label'))
}

# copy in the censor variable into the analysis settings. if the censoring changes,
# basically everything changes
for(ii in seq_along(analysis_settings_clean)) {
  analysis_settings_clean[[ii]]$censor_info = time_censor
  analysis_settings_clean[[ii]]$censor_info$window %<>% unlist
}


#### checks on condition groupings
for(ii in seq_along(first_condition_groupings)) {
  if(!nzchar(first_condition_groupings[[ii]]$label)) {
    first_condition_groupings[[ii]]$label = paste('Group', ii)
  }
}

#ensure no duplicate condition names
dd <- duplicated(sapply(first_condition_groupings, `[[`, 'label'))
while(sum(dd)) {
  for(w in which(dd)) {
    first_condition_groupings[[w]]$label = paste(first_condition_groupings[[w]]$label,
                                                 rand_string(length = 4))
  }
  dd <- duplicated(sapply(first_condition_groupings, `[[`, 'label'))
}

# ensure second-level trial groupings accord with the first level
fcg <- c(unlist(sapply(first_condition_groupings, `[[`, 'conditions')))
if(isTRUE(enable_second_condition_groupings)) {
  scg <- c(unlist(sapply(second_condition_groupings, `[[`, 'conditions')))
  stopifnot(setequal(scg,fcg))
  stopifnot(all(!duplicated(scg)))
}

# we can't have duplicates in trial groupings
if(any(duplicated(fcg))) {
  warning("Duplication in first factor, results may be unreliable")
}

if(is.list(trial_outliers_list)) {
  trial_outliers_list %<>% unlist
}

analysis_checks_passed=TRUE
```

```{rave calculate_baseline, language = "R", export = "baselined_power", cue = "always"}
stopifnot(analysis_checks_passed)

raveio::with_future_parallel({
    raveio::power_baseline(
        x = repository,
        baseline_windows = unlist(baseline_settings$window[[1]]),
        method = get_unit_of_analysis(baseline_settings$unit_of_analysis),
        units = get_baseline_scope(baseline_settings$scope),
        signal_type = "LFP",
        electrodes = requested_electrodes
    )
})
baselined_power <- subset(repository$power$baselined,
    Electrode ~ Electrode %in% requested_electrodes)
```

```{rave build_analysis_groups, language = "R", export = "analysis_groups"}
# build the groups from the first_condition_groupings variable (eventually add in the 2 cond group)
analysis_groups <- mapply(function(cg, ii) {
    trials <- c()
    if(length(cg$conditions)>0) {
        trials <- repository$epoch$table$Trial[
            repository$epoch$table$Condition %in% cg$conditions
        ]
    }
    
    list(
      label = cg$label,
      conditions = cg$conditions,
      trials = trials,
      index = ii,
      has_trials = length(trials) > 0#,
      # electrodes = requested_electrodes
    )
}, first_condition_groupings, seq_along(first_condition_groupings), SIMPLIFY = FALSE)

names(analysis_groups) <- sapply(analysis_groups, `[[`, 'label')

if(!any(vapply(analysis_groups, `[[`, FALSE, 'has_trials'))) stop('No trials available in condition groups')
```

```{rave build_pluriform_power, language = "R", export = "pluriform_power"}
epoch_event_types = get_available_events(repository$epoch$columns)

pluriform_power <- sapply(analysis_groups, function(ag) {
    # ag <- analysis_groups[[1]]
    sapply(analysis_settings, function(as) {
        # as <- analysis_settings[[1]]
        p <- get_pluriform_power(
            baselined_data=baselined_power,
            trial_indices = ag$trials,
            events = repository$epoch$table,
            epoch_event_types = epoch_event_types,
            trial_outliers_list=unlist(trial_outliers_list),
            event_of_interest = as$event,
        )
        list('data'=p, 'settings'=as)
    }, simplify = FALSE, USE.NAMES = TRUE)
}, simplify = FALSE, USE.NAMES = TRUE)


# now create frequency-subsetted versions of the data
for(gg in seq_along(pluriform_power)) {
  for(aa in seq_along(pluriform_power[[gg]])) {
    fi <- as.numeric(dimnames(pluriform_power[[gg]][[aa]]$data$shifted_data)$Frequency) %within% 
      unlist(pluriform_power[[gg]][[aa]]$settings$frequency)
    
    pluriform_power[[gg]][[aa]]$data$shifted_data_Fsub <- pluriform_power[[gg]][[aa]]$data$shifted_data[fi,,,,drop=FALSE]
    
    pluriform_power[[gg]][[aa]]$data$shifted_clean_data_Fsub <-  pluriform_power[[gg]][[aa]]$data$shifted_clean_data[fi,,,,drop=FALSE]
  }
}
```

```{rave build_overall_tf_data, language="R", export ="by_frequency_over_time_data"}
build_data <- function(data, analysis_settings, condition_group, baseline_settings, ...) {
  dn <- dimnames(data)
  stopifnot(c('Time', 'Frequency') == names(dn)[2:1])
  
  res <- list(
    data = raveio::collapse2(data, keep = 2:1, method = "mean"),
    
    x = as.numeric(dn$Time),
    y = as.numeric(dn$Frequency),
    
    xlab='Time (s)', ylab='Frequency',
    zlab='Mean ' %&% baseline_settings$unit_of_analysis
  )
  
  # determine range under censoring
  if(isTRUE(analysis_settings$censor_info$enabled)) {
    ti = res$x %within% settings$censor_info$window
    res$range <- range(res$data[!ti,])
  } else {
    res$range <- range(res$data)
  }
  
  return(res)
}

by_frequency_over_time_data <- data_builder(pluriform_power = pluriform_power,
                                            condition_group = analysis_groups, 
                                            baseline_settings = baseline_settings,
                                            build_data, data_type = 'shifted_clean_data')
```

```{rave build_tf_correlation_data, language="R", export = "by_frequency_correlation_data"}

# for each analysis settings in the overall_tf_data, get the correlation within the time window
if(length(analysis_settings) == 1) {
    # we only have one set of settings, so just get the correlations within each of the conditions
    tf_correlation_data <- vector("list", length = length(overall_tf_data))
    
    for(ii in seq_along(tf_correlation_data)) {
        d <- pluriform_power[[ii]][[1]]$data$shifted_clean_data
        
        tm <- as.numeric(dimnames(d)$Time)
        
        ti <- tm %within% unlist(pluriform_power[[ii]][[1]]$settings$time)
        if(isTRUE(pluriform_power[[ii]][[1]]$settings$censor_info$enabled)) {
            ti = ti & (tm %within% unlist(pluriform_power[[ii]][[1]]$settings$censor_info$window))
        }
        stopifnot(c('Frequency', 'Time') == names(dimnames(d))[1:2])
        
        d_collapsed <- ravetools::collapse(d[,ti,,,drop=FALSE], keep = c(2,1))
        tf_correlation_data[[ii]] <- list(
            data = cor(d_collapsed),
            xlab='',
            ylab='',
            zlab='Pearson correlation',
            x = as.numeric(dimnames(d)[[1]]),
            y = as.numeric(dimnames(d)[[1]])
        )
        
        
        
        
        
    }
} else {
    stop('>1 analysis not yet support for tf_correlation_data')
}

```


```{rave build_by_trial_tf_data, language="R", export ="by_trial_tf_data"}
build_data <- function(dd, settings) {
  to_keep <- sapply(c('Time', 'Trial'), which.equal, names(dimnames(dd)))
  res <- list(
    data = ravetools::collapse(dd, keep = to_keep),
    xlab='Time (s)', ylab='Original Trial #',
    zlab='Mean ' %&% baseline_settings$unit_of_analysis
  )
  
  res[c('x', 'y')] <- dimnames(dd)[to_keep] %>% lapply(as.numeric)
  
  res$N = dim(dd)[4L]
  
  if(isTRUE(settings$censor_info$enabled)) {
    ti = res$x %within% settings$censor_info$window
    res$range <- range(res$data[!ti,])
  } else {
    res$range <- range(res$data)
  }
  
  return(res)
}

by_trial_tf_data <- lapply(pluriform_power, function(pp) {
  # rm(pp) <- pluriform_power[[1]]
  if(all(
    1 == length(table(sapply(pp, function(pi) pi$settings$event))),
    1 == length(table(sapply(pp, function(pi) str_collapse(pi$settings$frequency))))
  )) {
    # all analysis groups have the same time=0 and the same frequency range,
    # so we can show them on the same plot      
    build_data(pp[[1]]$data$shifted_data_Fsub, pp[[1]]$settings)
  } else {
    # analysis groups have different time shifts/frequencies, so they can not be shown on the same plot
    sapply(pp, function(ppa) {
      build_data(ppa$data$shifted_data_Fsub, ppa$settings)
    }, simplify = FALSE, USE.NAMES = TRUE)
  }
})

```

```{rave build_by_electrode_tf_data, language="R", export ="by_electrode_tf_data"}

build_data <- function(dd, settings) {
    to_keep <- sapply(c('Time', 'Electrode'), which.equal, names(dimnames(dd)))
    res <- list(
        data = ravetools::collapse(dd, keep = to_keep),
        xlab='Time (s)', ylab='Electrode #', zlab='Mean ' %&% baseline_settings$unit_of_analysis
    )
    
    res[c('x', 'y')] <- dimnames(dd)[to_keep] %>% lapply(as.numeric)
    
    res$N = length(dimnames(dd)$Trial)
    
    if(isTRUE(settings$censor_info$enabled)) {
        ti = res$x %within% settings$censor_info$window
        res$range <- range(res$data[!ti,])
    } else {
        res$range <- range(res$data)
    }
    
    return(res)
}

over_time_by_electrode_data <- data_builder(pluriform_power = pluriform_power,
                                            condition_group = analysis_groups, 
                                            baseline_settings = baseline_settings,
                                            build_data)


```

```{rave plot_over_time_by_electrode_data_data, language='R', export='betfd_success', cue="always"}

betfd_success <- tryCatch({
  draw_many_heat_maps(over_time_by_electrode_data)
  
  TRUE
}, error=function(e) {
  e
})
```

```{rave build_over_time_by_condition_data, language="R", export ="over_time_by_condition_data"}
build_data <- function(dd, settings) {
    to_keep <- sapply(c('Time', 'Electrode'), which.equal, names(dimnames(dd)))
    res <- list(
        data = ravetools::collapse(dd, keep = to_keep),
        xlab='Time (s)',
        ylab='Mean ' %&% baseline_settings$unit_of_analysis,
        zlab=NA
    )
    
    # no get m_se across electrode at each time point
    res$data <- cbind(
        .rowMeans(res$data, nrow(res$data), ncol(res$data)),
        sqrt(diag(fastcov2(t(res$data))) / ncol(res$data))
    )
    
    res$x <- as.numeric(dimnames(dd)$Time)
    res$y <- NA
    res$N = length(dimnames(dd)$Electrode)
    
    if(isTRUE(settings$censor_info$enabled)) {
        ti = res$x %within% settings$censor_info$window
        res$range <- range(plus_minus(res$data[!ti,]))
    } else {
        res$range <- range(plus_minus(res$data))
    }
    
    return(res)
}

over_time_data <- lapply(pluriform_power, function(pp) {
    # rm(pp) <- pluriform_power[[1]]
    if(length(pp) == 1 || 
            all(
                1 == length(table(sapply(pp, function(pi) pi$settings$event))),
                1 == length(table(sapply(pp, function(pi) str_collapse(pi$settings$frequency))))
            )
    ){
        # all analysis groups have the same time=0, so we can show them on the same plot      
        build_data(pp[[1]]$data$shifted_clean_data_Fsub, pp[[1]]$settings)
    } else {
        # analysis groups have different time shifts, so they can not be shown on the same plot
        sapply(pp, function(ppa) {
            build_data(ppa$data$shifted_clean_data_Fsub, ppa$settings)
        }, simplify = FALSE, USE.NAMES = TRUE)
    }
})
```

```{rave build_scatter_bar_data, language="R", export ="scatter_bar_data"}
build_data <- function(dd, settings) {
  dm <- dimnames(dd)
  to_keep <- which.equal('Trial', names(dm))
  
  # make sure the time dimension is index 2
  stopifnot(which.equal('Time', names(dm)) == 2)
  
  t_ind <- as.numeric(dm$Time) %within% unlist(settings$time)
  
  if(isTRUE(settings$censor_info$enabled)) {
    t_ind = t_ind & !(
      as.numeric(dm$Time) %within% unlist(settings$censor_info$window)
    )
  }
  
  res <- list(
    data = ravetools::collapse(dd[,t_ind,,,drop=FALSE], keep = to_keep),
    xlab='Group',
    ylab='Mean ' %&% baseline_settings$unit_of_analysis,
    zlab=NA
  )
  res$range <- range(res$data)
  
  # here maybe store the jitter?
  #FIXME
  res$x <- NA
  res$y <- NA
  res$N = length(dimnames(dd)$Trial)
  
  return(res)
}

# scatter_bar_data <- lapply(pluriform_power, function(pp) {
#   sapply(pp, function(ppa) {
#     build_data(ppa$data$shifted_clean_data_Fsub, ppa$settings)
#   }, simplify = FALSE, USE.NAMES = TRUE)
# })
scatter_bar_data=FALSE

```

```{rave build_analysis_data, language="R", export="analysis_data"}
# build a dataframe for each analysis type and (within trial grouping)
# and then rbind the result

# building the data frame basically means combining information from
# the settings and the trial-collapsed data

# first determine if there are any 0-trial groups
has_data <- which(sapply(analysis_groups, `[[`, 'has_trials'))

analysis_data <- list()
# analysis_data$data <- mapply(function(pp, nm) {
#   
#   sapply(pp, function(ppi) {
#     freq <- "FW" %&% str_collapse(ppi$settings$frequency, '_')
#     aw <- "AW" %&% str_collapse(ppi$settings$time, '_')
#     lbl <- ppi$settings$label
#     
#     data <- ppi$data$shifted_data_Fsub
#     
#     ##make sure the time dimension is 2
#     dm <- dimnames(data)
#     to_keep <- which.equal('Trial', names(dm))
#     
#     # make sure the time dimension is index 2
#     stopifnot(which.equal('Time', names(dm)) == 2 && which.equal('Electrode', names(dm)) == 4)
#     
#     t_ind <- as.numeric(dm$Time) %within% ppi$settings$time
#     
#     if(isTRUE(ppi$settings$censor_info$enabled)) {
#       t_ind = t_ind & !(
#         as.numeric(dm$Time) %within% ppi$settings$censor_info$window
#       )
#     }
#     
#     d <- ravetools::collapse(data[,t_ind,,,drop=FALSE], keep=3:4)
#     rep_numeric <- function(str, ...) rep(as.numeric(str), ...)
#     
#     df <- data.frame(
#       Trial_Group = nm,
#       Electrode = rep_numeric(dm$Electrode, each=nrow(d)),
#       Trial = rep_numeric(dm$Trial, times=ncol(d)),
#       Frequency = freq,
#       Window = aw,
#       Name = lbl,
#       y = c(d)
#     )
# 
#     df
#   }, simplify = FALSE, USE.NAMES = TRUE)
#   
# }, pluriform_power[has_data], names(pluriform_power)[has_data]) %>% rbind_list

# # set outlier column
# analysis_data$data$is_clean = TRUE
# if(length(trial_outliers_list)) {
#   analysis_data$data$is_clean[analysis_data$data$Trial %in% trial_outliers_list] = FALSE
# }

analysis_data$datatype <- baseline_settings$unit_of_analysis
```


```{rave build_over_time_by_electrode_dataframe, language='R', export='over_time_by_electrode_dataframe'}
over_time_by_electrode_dataframe <- NULL
# building data for the movie viewer
# first baseline all the electrodes
raveio::power_baseline(
  repository,
  baseline_windows = baseline_settings$window,
  method = get_unit_of_analysis(baseline_settings$unit_of_analysis),
  units = get_baseline_scope(baseline_settings$scope),
  signal_type = "LFP",
  electrodes = repository$electrode_list
)

# for each condition group and for each analysis setting
# get one value per TIME per electrode
non_empty_groups <- which(rutabaga::get_list_elements(
  analysis_groups, 'has_trials'))

combine_if_equal <- function(ll, nms = c('Electrode', 'Time')) {
  if(length(ll) == 1) {
    return(ll[[1]])
  }
  r1 <- ll[[1]]
  
  for(jj in seq_along(ll)[-1]) {
    
    stopifnot(all(
      dim(r1) == dim(ll[[jj]]),
      sapply(nms, function(nm) {
        all.equal(r1[[nm]], ll[[jj]][[nm]])
      })
    ))
  }
  r1
  for(jj in seq_along(ll)[-1]) {
    cn <- names(ll[[jj]])
    to_move = setdiff(cn, nms)
    
    r1[to_move] = ll[[jj]][to_move]
  }
  
  return(r1)
}

by_condition_group <-
  lapply(analysis_groups[non_empty_groups],
         function(ag) {
           res <- lapply(analysis_settings_clean, function(as) {
             # as = analysis_settings_clean[[1]]
             # freq needed
             fi <- repository$frequency %within% as$frequency
             
             # shift the data and subset on trials/freq
             p <- get_pluriform_power(
               baselined_data=repository$power$baselined[fi,,,,drop=FALSE],
               trial_indices = ag$trials, events = repository$epoch$table,
               epoch_event_types = get_available_events(repository$epoch$columns), trial_outliers_list=unlist(trial_outliers_list),
               event_of_interest = as$event, final_data_only=TRUE,
               sample_rate = repository$subject$power_sample_rate
             )
             
             # make sure dimensions are what we think they are
             stopifnot(
               names(dimnames(p)) == c('Frequency', 'Time', 'Trial', 'Electrode')
             )
             
             enames = as.integer(dimnames(p)$Electrode)
             times = as.numeric(dimnames(p)$Time)
             
             m <- ravetools::collapse(p[drop=FALSE], keep = c(4,2))
             
             df <- data.frame(
               reshape2::melt(m,
                              value.name=paste(sep='_', as$label, ag$label))
             )
             # head(df)
             names(df)[1:2] = c('Electrode', 'Time')
             df$Electrode = enames[df$Electrode]
             df$Time = times[df$Time]
             
             return(df)
           })
           
           # confirm everything lines up
           combine_if_equal(res)
         }
  )

#merge the resulting datasets
over_time_by_electrode_dataframe <- by_condition_group[[1]]

if(length(by_condition_group) > 1) {
  for(ii in seq_along(by_condition_group)[-1]){
    over_time_by_electrode_dataframe = merge(over_time_by_electrode_dataframe,
                                             by_condition_group[[ii]],
                                             all=TRUE)
  }
}

```

```{rave build_over_time_by_trial, language="R", export ="over_time_by_trial_data"}

build_data <- function(data, analysis_settings, condition_group, baseline_settings, ...) {
  
  dm <- dimnames(data)
  
  to_keep <- c(
    which.equal('Time', names(dm)),
    which.equal('Trial', names(dm))
  )
  
  res <- list(
    data = ravetools::collapse(data[,drop=FALSE], keep = to_keep),
    x = as.numeric(dm$Time),
    xlab='Time',
    ylab='Trial (sorted by condition)',
    zlab=sprintf('Mean %s', baseline_settings$unit_of_analysis)
  )
  
  res$range <- range(res$data)
  ind <- which(sapply(first_condition_groupings, `[[`, 'label')==condition_group[[1]])
  cnds <- first_condition_groupings[[ind]]$conditions
  
  tt = as.numeric(dm$Trial)
  res$y = trial_details[as.character(tt), 'Condition']
  cf <- factor(res$y, levels = cnds)
  ord = order(cf, tt)
  
  # sort the trial labels
  res$y <- res$y[ord]
  
  # NB: the condition data are stored in the COLUMNS of the data, so sort appropriately
  # this may feel odd, but this is because of how image(...) function works
  res$data <- res$data[,ord]
  
  return(res)
}

over_time_by_trial_data <- data_builder(
  pluriform_power, condition_groups = analysis_groups,
  baseline_settings = baseline_settings,
  BUILDER_FUN = build_data, 
  data_type = 'shifted_clean_data_Fsub'
)

```


```{rave build_over_time_by_electrode_dataframe, language='R', export = 'over_time_by_electrode_dataframe'}
over_time_by_electrode_dataframe <- NULL
# building data for the movie viewer
# first baseline all the electrodes
raveio::power_baseline(
  repository,
  baseline_windows = baseline_settings$window,
  method = get_unit_of_analysis(baseline_settings$unit_of_analysis),
  units = get_baseline_scope(baseline_settings$scope),
  signal_type = "LFP",
  electrodes = repository$electrode_list
)

# for each condition group and for each analysis setting
# get one value per TIME per electrode
non_empty_groups <- which(rutabaga::get_list_elements(
  analysis_groups, 'has_trials'))

by_condition_group <- raveio::lapply_async(
  analysis_groups,
  callback = function(x) {
    paste('[build_over_time_by_electrode_dataframe] working on:', x$label, 'data')
  }, 
  # lapply(analysis_groups[non_empty_groups],
  FUN = function(ag) {
    res <- lapply(analysis_settings_clean, function(as) {
      # as = analysis_settings_clean[[1]]
      # freq needed
      fi <- repository$frequency %within% as$frequency
      
      # shift the data and subset on trials/freq
      p <- get_pluriform_power(
        baselined_data=repository$power$baselined[fi,,,,drop=FALSE],
        trial_indices = ag$trials, events = repository$epoch$table,
        epoch_event_types = get_available_events(repository$epoch$columns), trial_outliers_list=unlist(trial_outliers_list),
        event_of_interest = as$event, final_data_only=TRUE,
        sample_rate = repository$subject$power_sample_rate
      )
      
      # make sure dimensions are what we think they are
      stopifnot(
        names(dimnames(p)) == c('Frequency', 'Time', 'Trial', 'Electrode')
      )
      
      enames = as.integer(dimnames(p)$Electrode)
      times = as.numeric(dimnames(p)$Time)
      
      m <- ravetools::collapse(p[drop=FALSE], keep = c(4,2))
      
      df <- data.frame(
        reshape2::melt(m,
                       value.name=paste(sep='_', as$label, ag$label))
      )
      # head(df)
      names(df)[1:2] = c('Electrode', 'Time')
      df$Electrode = enames[df$Electrode]
      df$Time = times[df$Time]
      
      return(df)
    })
    
    
    if(length(res) == 1) {
      return(res[[1]])
    }
    
    # merge the data if more than one 
    merged_res <- res[[1]]
    
    for(ri in seq_along(res)[-1]) {
      merged_res = merge(merged_res, res[[ri]], all=TRUE)
    }
    
    return(merged_res)
  }
)

#merge the resulting data sets
over_time_by_electrode_dataframe <- by_condition_group[[1]]

if(length(by_condition_group) > 1) {
  for(ii in seq_along(by_condition_group)[-1]){
    over_time_by_electrode_dataframe = merge(over_time_by_electrode_dataframe,
                                             by_condition_group[[ii]],
                                             all=TRUE)
  }
}
```

```{rave build_over_time_by_trial, language="R", export ="over_time_by_trial_data"}

build_data <- function(data, analysis_settings, condition_group, baseline_settings, ...) {
  
  dm <- dimnames(data)
  
  to_keep <- c(
    which.equal('Time', names(dm)),
    which.equal('Trial', names(dm))
  )
  
  res <- list(
    data = ravetools::collapse(data[,drop=FALSE], keep = to_keep),
    x = as.numeric(dm$Time),
    xlab='Time',
    ylab='Trial (sorted by condition)',
    zlab=sprintf('Mean %s', baseline_settings$unit_of_analysis)
  )
  
  res$range <- range(res$data)
  # ind <- which(sapply(first_condition_groupings, `[[`, 'label')==condition_group[[1]])
  # cnds <- first_condition_groupings[[ind]]$conditions
  
  cnds <- condition_group$conditions
  tt <- condition_group$trials
  
  res$y <-trial_details[as.character(tt), condition_variable]
  cf <- factor(res$y, levels = cnds)
  ord = order(cf, tt)
  
  # sort the trial labels
  res$y <- res$y[ord]
  
  # now add in trial nunber and outlier status, using the sorted order
  res$trial_number = tt[ord]
  res$is_outlier = tt[ord] %in% trial_outliers_list
  
  # NB: the condition data are stored in the COLUMNS of the data, so sort appropriately
  # this may feel odd, but this is because of how image(...) function works
  res$data <- res$data[,ord]
  
  return(res)
}

over_time_by_trial_data <- data_builder(
  pluriform_power, condition_groups = analysis_groups,
  baseline_settings = baseline_settings,
  BUILDER_FUN = build_data, 
  data_type = 'shifted_data_Fsub'
  # we want the uncleaned data so we can highlight outliers on this plot
  # data_type = 'shifted_clean_data_Fsub'
)

```

```{rave build_internal_omnibus_results, language="R", export="internal_omnibus_results"}
# set 16 GiB export size? // set this based on RAM?
options(future.globals.maxSize =  16 * 1024^3)

# first baseline all the electrodes
raveio::power_baseline(
  repository,
  baseline_windows = baseline_settings$window,
  method = get_unit_of_analysis(baseline_settings$unit_of_analysis),
  units = get_baseline_scope(baseline_settings$scope),
  signal_type = "LFP",
  electrodes = repository$electrode_list
)

# for each condition group and for each analysis setting
# get one value per trial per electrode
non_empty_groups <- which(rutabaga::get_list_elements(analysis_groups, 'has_trials'))
by_condition_group <- raveio::lapply_async(
  x = analysis_groups[non_empty_groups],
  function(ag) {
    lapply(analysis_settings_clean, function(as) {
      # as <- analysis_settings_clean[[1]]
      # freq needed
      fi <- repository$frequency %within% as$frequency
      
      # ei <- repository$electrode_list %in% ag$electrodes
      
      # shift the data and subset on trials/freq
      # Note: we're subsetting frequency in the call
      all_p <- get_pluriform_power(
        baselined_data=repository$power$baselined[fi,,,,drop=FALSE],
        trial_indices = ag$trials, events = repository$epoch$table,
        epoch_event_types = get_available_events(repository$epoch$columns),
        trial_outliers_list=unlist(trial_outliers_list),
        event_of_interest = as$event, 
        # final_data_only=TRUE,
        sample_rate = repository$subject$power_sample_rate
      )
      
      p <- all_p$shifted_data
      ti = as.numeric(dimnames(p)$Time) %within% as$time
      stopifnot(names(dimnames(p))[2] == 'Time')
      
      # average within Time and Freq windows. Freq has already been subsetted
      m <- ravetools::collapse(p[,ti,,,drop=FALSE], keep = 3:4)
      
      mse <- apply(m, 2, rutabaga::m_se)
      ts = mse[1,] / mse[2,]
      collapsed <- cbind(mse[1,],
                         ts,
                         2*pt(abs(ts), df = nrow(m)-1, lower.tail = F)
      )
      enames = dimnames(p)$Electrode
      rownames(collapsed) = enames
      colnames(collapsed) = paste0(c('m', 't', 'p'), '(', ag$label,   '; ', as$label, ')')
      
      trial_column <- rep(dimnames(p)$Trial, times=ncol(m))
      
      by_trial <- data.frame(
        'y' = c(m),
        'Electrode' = rep(as.numeric(enames), each=nrow(m)),
        
        # use dimnames(p) here rather than ag$Trials because of potential outliers
        'Trial' = trial_column,
        'is_clean' = !(trial_column %in% trial_outliers_list),
        'Factor1' = ag$label,
        'Time' =  't' %&% str_collapse(as$time, '-'),
        'Freq' =  'f' %&% str_collapse(as$frequency, '-'),
        'Event' = as$event,
        'AnalysisLabel' = as$label
      )
      
      return(list('df' = by_trial, 'collapsed'=collapsed))
    })
  })

all_data <- rutabaga::rbind_list(sapply(by_condition_group, 
                                        rutabaga::get_list_elements, 'df', use_sapply=FALSE))

# if we have a second factor (eventually an ROI) we need to clean up the naming
if(isTRUE(enable_second_condition_groupings)) {
  meta_table <- attr(analysis_groups, 'meta')
  
  stopifnot(is.data.frame(meta_table))
  
  all_data$Factor1 = NULL
  all_data %<>% merge(meta_table, by=c('Trial'))
  
  # add in an interaction factor
  all_data$Factor1Factor2 = mapply(paste, all_data$Factor1, all_data$Factor2, sep='.')
  
  # sort the levels
  all_data$Factor1Factor2 %<>% factor(levels = names(analysis_groups))
  
} else {
  if(!is.factor(all_data$Factor1)) {
    all_data$Factor1 %<>% factor(levels = names(by_condition_group))
  }
}

# make sure analysis label is appropriately factored
if(!is.null(all_data$AnalysisLabel)) {
  all_data$AnalysisLabel %<>% factor(levels = names(analysis_settings_clean))
}

# copy of the data with the outliers removed (for stats etc)
all_data_clean <- subset(all_data, is_clean)

# collapsed_data <- cbind_list(sapply(by_condition_group, 
# get_list_elements, 'collapsed', use_sapply=FALSE))

# for the stats, we need to figure out the factors involved and then build 
# the appropriate model
# for the post hocs, just get all pairwise for now. we'll need to have some
# kind of chooser for specific contrasts in the future (duplicate with group module)
get_factor_length <- function(x) length(unique(all_data_clean[[x]]))
repeated_factors <- 'AnalysisLabel' #c('Time', 'Freq', 'Event')
unrepeated_factors <- c('Factor1', 'Factor2')
factor_lengths <- sapply(c(repeated_factors, unrepeated_factors), get_factor_length)
fixed_effects <- names(factor_lengths[factor_lengths>1])

formula_str <- paste0('y ~ ', str_collapse(fixed_effects, '*'))
if(formula_str == 'y ~ ') formula_str = 'y ~ 1' 

has_re <- any(repeated_factors %in% fixed_effects)
stat_fun <- stats::lm
if(has_re) {
  formula_str %<>% paste("+ (1|Trial)")
  stat_fun <- lmerTest::lmer
} 

formula_frm = as.formula(formula_str)

run_stats <- function(el) {
  mod <- stat_fun(formula_frm, data=el)
  
  if(length(coef(mod)) == 1 && class(mod) != 'lmerModLmerTest') {
    lsm <- emmeans::emmeans(mod, specs = '1')
    summ <- summary(lsm, infer = TRUE)
    emm = matrix(unlist(t(summ[c('emmean', 't.ratio', 'p.value')])))
    lbls <- as.character(summ[[1]])
    
    rownames(emm) = c(outer(c('m(', 't(', 'p('),lbls, paste0)) %&% ')'
    
    res <- emm
  } else {
    
    lsm <- emmeans::emmeans(mod, as.formula('pairwise ~' %&% str_collapse(fixed_effects, '*')))
    summ <- summary(lsm$emmeans, infer = TRUE)
    emm = matrix(unlist(t(summ[c('emmean', 't.ratio', 'p.value')])))
    lbls <- apply(summ[,fixed_effects,drop=FALSE], 1, str_collapse, by=' ')
    
    rownames(emm) = c(outer(c('m(', 't(', 'p('),lbls, paste0)) %&% ')'
    
    cntr = summary(lsm, adjust='fdr')$contrasts
    cmat = matrix(unlist(t(cntr[,c('estimate','t.ratio', 'p.value')])))
    rownames(cmat) = c(t(sapply(c('m(', 't(', 'p_fdr('), paste0, cntr$contrast))) %&% ')'
    
    # get the overall results to add
    tmp <- summary(emmeans::emmeans(mod, specs='1'), infer=TRUE)
    tmp.emm = matrix(unlist(t(tmp[c('emmean', 't.ratio', 'p.value')])))
    tmp.lbls <- as.character(tmp[[1]])
    
    rownames(tmp.emm) = c(outer(c('m(', 't(', 'p('),tmp.lbls, paste0)) %&% ')'
    
    res <- rbind(tmp.emm, emm, cmat)
  }
  colnames(res) = el$Electrode[1]
  
  return(res)
}

# now we want to calculate the stats for each electrode
stats <- all_data_clean %>% split((.)$Electrode) %>% 
  raveio::lapply_async(function(el){
    # lapply(function(el) {
      # print(el$Electrode[1])
      if(var(el$y) < 1e-12) {
        return(NULL)
      }
    # tryCatch({
    # return(suppressMessages(
    run_stats(el)
    # )
    # )
    # }, error = function(...) {
    # The data contains NA/NaN
    # NULL
    # })
  }) %>%
  rutabaga::cbind_list()

# add in electrode labels as an attribute of the stats block.
# don't add as row, otherwise we lose numeric-ness
attr(stats, 'electrode_labels') = repository$electrode_table$Label

# add in the Block information from the epoch file, could be useful to assess 
# large changes in effect size over time 
all_data %<>% merge(repository$epoch$table[,c('Block', 'Trial')], sort=FALSE)

#combine into large list for exporting
internal_omnibus_results = list(
  # 'collapsed' = collapsed_data,
  'data_with_outliers' = all_data,
  'data' = all_data_clean,
  'stats' = stats
)
```


```{rave build_omnibus_results, language="R", export="omnibus_results"}
# 
omnibus_results <- 1
# 
# # first baseline all the electrodes
# raveio::with_future_parallel({
#   raveio::power_baseline(
#     x = repository,
#     baseline_windows = unlist(baseline_settings$window[[1]]),
#     method = get_unit_of_analysis(baseline_settings$unit_of_analysis),
#     units = get_baseline_scope(baseline_settings$scope),
#     signal_type = "LFP",
#     electrodes = repository$electrode_list
#   )
# })
```

```{r build, echo=FALSE, results='hide'}
build_pipeline(make_file = "make-power_explorer.R")
```

```{r visualize, echo=FALSE}
Sys.setenv("RAVE_PIPELINE" = normalizePath("."))
raveio::pipeline_visualize()
```
